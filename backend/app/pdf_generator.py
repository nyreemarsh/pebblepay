"""
PDF Generator for Contracts
Creates professional, well-formatted PDF contracts.
"""
import io
from datetime import datetime
from typing import Dict, Any
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, HRFlowable
from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT


def generate_contract_pdf(contract_text: str, contract_spec: Dict[str, Any]) -> bytes:
    """
    Generate a professional PDF from contract text and spec.
    
    Args:
        contract_text: The full contract text
        contract_spec: The contract specification dict
        
    Returns:
        PDF file as bytes
    """
    buffer = io.BytesIO()
    
    # Create document
    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        rightMargin=2*cm,
        leftMargin=2*cm,
        topMargin=2*cm,
        bottomMargin=2*cm,
    )
    
    # Get styles
    styles = getSampleStyleSheet()
    
    # Custom styles
    title_style = ParagraphStyle(
        'ContractTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=TA_CENTER,
        textColor=colors.HexColor('#1a1a2e'),
    )
    
    heading_style = ParagraphStyle(
        'SectionHeading',
        parent=styles['Heading2'],
        fontSize=14,
        spaceBefore=20,
        spaceAfter=10,
        textColor=colors.HexColor('#16213e'),
        borderPadding=5,
    )
    
    body_style = ParagraphStyle(
        'ContractBody',
        parent=styles['Normal'],
        fontSize=11,
        leading=16,
        alignment=TA_JUSTIFY,
        spaceAfter=8,
    )
    
    small_style = ParagraphStyle(
        'SmallText',
        parent=styles['Normal'],
        fontSize=9,
        textColor=colors.grey,
        alignment=TA_CENTER,
    )
    
    # Build content
    story = []
    
    # Title
    title = contract_spec.get("title", "Freelance Service Agreement")
    story.append(Paragraph(title.upper(), title_style))
    story.append(Spacer(1, 0.3*inch))
    
    # Date line
    today = datetime.now().strftime("%B %d, %Y")
    story.append(Paragraph(f"<i>Effective Date: {today}</i>", small_style))
    story.append(Spacer(1, 0.3*inch))
    
    # Divider
    story.append(HRFlowable(width="100%", thickness=2, color=colors.HexColor('#1D838D')))
    story.append(Spacer(1, 0.2*inch))
    
    # Parse and format contract text
    sections = parse_contract_sections(contract_text)
    
    for section_title, section_content in sections:
        if section_title:
            story.append(Paragraph(section_title, heading_style))
        
        # Clean and format content
        for para in section_content.split('\n\n'):
            para = para.strip()
            if para:
                # Handle bullet points
                if para.startswith('•') or para.startswith('-') or para.startswith('*'):
                    para = para.replace('•', '&bull;').replace('- ', '&bull; ').replace('* ', '&bull; ')
                story.append(Paragraph(para, body_style))
        
        story.append(Spacer(1, 0.1*inch))
    
    # Signature section
    story.append(Spacer(1, 0.5*inch))
    story.append(HRFlowable(width="100%", thickness=1, color=colors.grey))
    story.append(Spacer(1, 0.3*inch))
    
    story.append(Paragraph("SIGNATURES", heading_style))
    story.append(Spacer(1, 0.2*inch))
    
    # Get party names
    freelancer = contract_spec.get("freelancer", {}) or {}
    client = contract_spec.get("client", {}) or {}
    freelancer_name = freelancer.get("name", "Freelancer")
    client_name = client.get("name", "Client")
    
    # Signature table
    sig_data = [
        ["FREELANCER:", "", "CLIENT:"],
        ["", "", ""],
        ["Signature: _______________________", "", "Signature: _______________________"],
        ["", "", ""],
        [f"Name: {freelancer_name}", "", f"Name: {client_name}"],
        ["", "", ""],
        ["Date: _______________________", "", "Date: _______________________"],
    ]
    
    sig_table = Table(sig_data, colWidths=[2.5*inch, 1*inch, 2.5*inch])
    sig_table.setStyle(TableStyle([
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('FONTNAME', (0, 0), (0, 0), 'Helvetica-Bold'),
        ('FONTNAME', (2, 0), (2, 0), 'Helvetica-Bold'),
    ]))
    
    story.append(sig_table)
    
    # Footer
    story.append(Spacer(1, 0.5*inch))
    story.append(HRFlowable(width="100%", thickness=1, color=colors.HexColor('#1D838D')))
    story.append(Spacer(1, 0.1*inch))
    story.append(Paragraph(
        f"Generated by PebblePay Contract Assistant • {today}",
        small_style
    ))
    
    # Build PDF
    doc.build(story)
    
    # Get PDF bytes
    pdf_bytes = buffer.getvalue()
    buffer.close()
    
    return pdf_bytes


def parse_contract_sections(contract_text: str) -> list:
    """
    Parse contract text into sections.
    Returns list of (title, content) tuples.
    """
    sections = []
    current_title = None
    current_content = []
    
    lines = contract_text.split('\n')
    
    for line in lines:
        line_stripped = line.strip()
        
        # Check if it's a section header (numbered or all caps)
        is_header = False
        
        # Numbered headers like "1. PARTIES" or "1. Parties"
        if line_stripped and len(line_stripped) > 2:
            if line_stripped[0].isdigit() and '.' in line_stripped[:3]:
                is_header = True
            # All caps headers
            elif line_stripped.isupper() and len(line_stripped) > 3 and len(line_stripped) < 50:
                is_header = True
            # Headers with === or ---
            elif line_stripped.startswith('===') or line_stripped.startswith('---'):
                continue  # Skip divider lines
        
        if is_header:
            # Save previous section
            if current_title or current_content:
                sections.append((current_title, '\n'.join(current_content)))
            current_title = line_stripped
            current_content = []
        else:
            if line_stripped:
                current_content.append(line_stripped)
    
    # Don't forget last section
    if current_title or current_content:
        sections.append((current_title, '\n'.join(current_content)))
    
    return sections


def generate_simple_contract_pdf(contract_spec: Dict[str, Any]) -> bytes:
    """
    Generate a simpler, template-based PDF when contract_text isn't available.
    """
    # Build contract text from spec
    contract_text = build_contract_from_spec(contract_spec)
    return generate_contract_pdf(contract_text, contract_spec)


def build_contract_from_spec(spec: Dict[str, Any]) -> str:
    """Build contract text from specification."""
    freelancer = spec.get("freelancer", {}) or {}
    client = spec.get("client", {}) or {}
    payment = spec.get("payment", {}) or {}
    timeline = spec.get("timeline", {}) or {}
    quality = spec.get("quality_standards", {}) or {}
    failure = spec.get("failure_scenarios", {}) or {}
    dispute = spec.get("dispute_resolution", {}) or {}
    
    deliverables = spec.get("deliverables", []) or []
    deliverables_text = "\n".join(f"• {d.get('item', d) if isinstance(d, dict) else d}" 
                                   for d in deliverables) or "• As agreed"
    
    return f"""
1. PARTIES

This Agreement is entered into between:

Freelancer: {freelancer.get('name', '[Name]')}
Email: {freelancer.get('email', '[Email]')}

Client: {client.get('name', '[Name]')}
Email: {client.get('email', '[Email]')}

2. SCOPE OF WORK

The Freelancer agrees to provide the following deliverables:

{deliverables_text}

3. PAYMENT TERMS

Total Fee: {payment.get('amount', '[Amount]')} {payment.get('currency', '')}
Payment Schedule: {payment.get('schedule', 'On completion')}

4. TIMELINE

Start Date: {timeline.get('start_date', 'Upon signing')}
Deadline: {timeline.get('deadline', '[Deadline]')}

5. REVISIONS

Number of revision rounds included: {quality.get('max_revisions', '2')}
Additional revisions will be charged at an agreed rate.

6. FAILURE SCENARIOS

Late Delivery: {failure.get('late_delivery', {}).get('penalty_type', 'No penalty')}

Non-Delivery: If Freelancer cannot complete the work, {failure.get('non_delivery', {}).get('refund_percentage', '100')}% refund will be provided.

Client Rejection: {failure.get('client_rejection', {}).get('process', 'Discussion and mediation')}

7. DISPUTE RESOLUTION

Method: {dispute.get('method', 'Negotiation first, then mediation')}

8. INTELLECTUAL PROPERTY

Final work ownership transfers to Client upon full payment.
Freelancer retains the right to display work in portfolio.

9. AGREEMENT

By signing below, both parties agree to the terms of this contract.
"""

